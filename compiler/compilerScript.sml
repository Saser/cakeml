(*Generated by Lem from compiler.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory semanticPrimitivesTheory astTheory compilerLibTheory intLangTheory toIntLangTheory toBytecodeTheory bytecodeTheory;

val _ = numLib.prefer_num();



val _ = new_theory "compiler"

(*open import Pervasives*) 

(*open import SemanticPrimitives*)
(*open import Ast*)
(*open import CompilerLib*)
(*open import IntLang*)
(*open import ToIntLang*)
(*open import ToBytecode*)
(*open import Bytecode*)

val _ = type_abbrev( "contab" , ``: (( ( conN id)option), num) fmap # (num #  ( conN id)option) list # num``);
(*val cmap : contab -> Map.map (maybe (id conN)) nat*)
 val _ = Define `
 (cmap (m,_,_) = m)`;


val _ = Hol_datatype `
 compiler_state =
  <| contab : contab
   ; renv : (string # num) list
   ; rmenv : (string, ( (string # num)list)) fmap
   ; rsz : num
   ; rnext_label : num
   |>`;


(*val cpam : compiler_state -> list (nat * maybe (id conN))*)
 val _ = Define `
 (cpam s = ((case s.contab of (_,w,_) => w )))`;


val _ = Define `
 (init_compiler_state =  
(<| contab := (((((((FEMPTY |+ (NONE, tuple_cn)) |+ ((SOME(Short"nil")), nil_exc_cn)) |+ ((SOME(Short"::")), cons_exc_cn)) |+ ((SOME(Short"Bind")), bind_exc_cn)) |+ ((SOME(Short"Div")), div_exc_cn)) |+ ((SOME(Short"Eq")), eq_exc_cn))
              ,[(eq_exc_cn,SOME(Short"Eq"))
               ;(div_exc_cn,SOME(Short"Div"))
               ;(bind_exc_cn,SOME(Short"Bind"))
               ;(cons_exc_cn,SOME(Short"::"))
               ;(nil_exc_cn,SOME(Short"nil"))
               ;(tuple_cn,NONE)]
              , 6)
   ; renv := []
   ; rmenv := FEMPTY
   ; rsz :=( 0)
   ; rnext_label :=( 0)
   |>))`;


 val _ = Define `

(number_constructors _ [] ct = ct)
/\
(number_constructors mn ((c,_)::cs) (m,w,n) =  
(number_constructors mn cs (m |+ ((SOME (mk_id mn c)), n), ((n,SOME (mk_id mn c))::w), (n+( 1:num)))))`;


 val _ = Define `

(dec_to_contab mn ct (Dtype ts) =  
(FOLDL (\ct p .  (case (ct ,p ) of ( ct , (_,_,cs) ) => number_constructors mn cs ct )) ct ts))
/\
(dec_to_contab mn ct (Dexn c ts) =  
(number_constructors mn [(c,ts)] ct))
/\
(dec_to_contab _ ct _ = ct)`;


 val decs_to_contab_defn = Hol_defn "decs_to_contab" `

(decs_to_contab _ ct [] = ct)
/\
(decs_to_contab mn ct (d::ds) = (decs_to_contab mn (dec_to_contab mn ct d) ds))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn decs_to_contab_defn;

 val compile_news_defn = Hol_defn "compile_news" `

(compile_news cs _ [] = (emit cs [Stack Pop]))
/\
(compile_news cs i (_::vs) =  
(let cs = (emit cs (MAP Stack [Load( 0); Load( 0); El i])) in
  let cs = (emit cs [Stack (Store( 1))]) in
  compile_news cs (i+ 1) vs))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compile_news_defn;

val _ = Define `
 (compile_Cexp menv env rsz cs Ce =  
(let (Ce,nl) = (label_closures (LENGTH env) cs.next_label Ce) in
  let cs = (compile_code_env menv ( cs with<| next_label := nl |>) Ce) in
  compile menv env TCNonTail rsz cs Ce))`;


val _ = Define `
 (compile_fake_exp menv m env rsz cs vs e =  
(let Ce = (exp_to_Cexp m (e (Con NONE (MAP (\ v .  Var (Short v)) (REVERSE vs))))) in
  compile_Cexp menv env rsz cs Ce))`;


 val _ = Define `

(compile_dec _ _ _ _ cs (Dtype _) = (NONE, emit cs [Stack (Cons (block_tag+tuple_cn)( 0))]))
/\
(compile_dec _ _ _ _ cs (Dexn _ _ ) = (NONE, emit cs [Stack (Cons (block_tag+tuple_cn)( 0))]))
/\
(compile_dec menv m env rsz cs (Dletrec defs) =  
(let vs = (MAP (\p .  
  (case (p ) of ( (n,_,_) ) => n )) defs) in
  (SOME vs, compile_fake_exp menv m env rsz cs vs (\ b .  Letrec defs b))))
/\
(compile_dec menv m env rsz cs (Dlet p e) =  
(let vs = (pat_bindings p []) in
  (SOME vs, compile_fake_exp menv m env rsz cs vs (\ b .  Mat e [(p,b)]))))`;


 val compile_decs_defn = Hol_defn "compile_decs" `

(compile_decs _ _ ct m _ rsz cs [] = (ct,m,rsz,cs))
/\
(compile_decs mn menv ct m env rsz cs (dec::decs) =  
(let (vso,cs) = (compile_dec menv m env rsz cs dec) in
  let ct = (dec_to_contab mn ct dec) in
  let vs = ((case vso of NONE => [] | SOME vs => vs )) in
  let n = (LENGTH vs) in
  let m = (( m with<| cnmap := cmap ct; bvars := vs++m.bvars |>)) in
  let env = ((GENLIST(\ i .  CTDec (((rsz+n)-  1)- i))n)++env) in
  let rsz = (rsz+n) in
  let cs = (compile_news cs( 0) vs) in
  compile_decs mn menv ct m env rsz cs decs))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compile_decs_defn;

val _ = Define `
 (compile_decs_wrap mn rs decs =  
(let cs = (<| out := []; next_label := rs.rnext_label |>) in
  let cs = (emit cs [PushPtr (Addr( 0)); PushExc]) in
  let menv = ((MAP SND) o_f rs.rmenv) in
  let m = (<| bvars := (MAP FST rs.renv)
           ; mvars := ((MAP FST) o_f rs.rmenv)
           ; cnmap := (cmap rs.contab)
           |>) in
  let env = (MAP (CTDec o SND) rs.renv) in
  let (ct,m,rsz,cs) = (compile_decs mn menv rs.contab m env (rs.rsz+ 2) cs decs) in
  let n = ((rsz -  2)- rs.rsz) in
  let news = (TAKE n m.bvars) in
  let cs = (emit cs [Stack (Cons tuple_cn n)]) in
  let cs = (emit cs [PopExc; Stack(Pops( 1))]) in
  let cs = (compile_news cs( 0) news) in
  let env = (ZIP (news, (GENLIST (\ i .  ((rs.rsz+n)-  1)- i) n))) in
  (ct,env,cs)))`;


 val _ = Define `

(compile_print_val TC_int s = (emit s [PrintInt]))
/\
(compile_print_val TC_string s = (emit s [PrintStr]))
/\
(compile_print_val TC_bool s =  
(let (s,n0) = (get_label s) in
  let (s,n1) = (get_label s) in
  emit s (((([JumpIf (Lab n0)]++
          (MAP PrintC (EXPLODE "false")))++
          [Jump (Lab n1); Label n0])++
          (MAP PrintC (EXPLODE "true")))++
          [Label n1])))
/\
(compile_print_val TC_unit s =  
(emit s (Stack Pop::(MAP PrintC (EXPLODE "()")))))
/\
(compile_print_val TC_fn s =  
(emit s (Stack Pop::(MAP PrintC (EXPLODE "<fn>")))))
/\
(compile_print_val TC_ref s =  
(emit s (Stack Pop::(MAP PrintC (EXPLODE "<ref>")))))
/\
(compile_print_val _ s =  
(emit s (Stack Pop::(MAP PrintC (EXPLODE "<constructor>")))))`;


 val _ = Define `

(compile_print_vals _ _ [] s = s)
/\
(compile_print_vals types n (v::vs) s =  
(let (tystr, tc0) = ((case FLOOKUP types v of   SOME p => p | NONE => ("<unknown>",TC_exn) )) in
  let s = (emit s (MAP PrintC (EXPLODE (CONCAT ["val ";v;":"; tystr; " = "])))) in
  let s = (emit s [Stack(Load n)]) in
  let s = (compile_print_val tc0 s) in
  let s = (emit s (MAP PrintC (EXPLODE "\n"))) in
    compile_print_vals types (n+ 1) vs s))`;


 val _ = Define `

(compile_print_ctors [] s = s)
/\
(compile_print_ctors ((c,_)::cs) s =  
(compile_print_ctors cs
    (emit s (MAP PrintC (EXPLODE (CONCAT [c;" = <constructor>\n"]))))))`;


 val _ = Define `

(compile_print_types [] s = s)
/\
(compile_print_types ((_,_,cs)::ts) s =  
(compile_print_types ts (compile_print_ctors cs s)))`;


 val _ = Define `

(compile_print_dec _ (Dtype ts) s = (compile_print_types ts s))
/\
(compile_print_dec _ (Dexn c xs) s = (compile_print_types [(([]: tvarN list),"exn",[(c,xs)])] s))
/\
(compile_print_dec types (Dlet p _) s =  
(compile_print_vals types( 0) (pat_bindings p []) s))
/\
(compile_print_dec types (Dletrec defs) s =  
(compile_print_vals types( 0) (MAP (\p .  
  (case (p ) of ( (n,_,_) ) => n )) defs) s))`;


 val _ = Define `

(compile_top _ rs (Tmod mn _ decs) =  
(let (ct,env,cs) = (compile_decs_wrap (SOME mn) rs decs) in
  let str = (CONCAT["structure ";mn;" = <structure>\n"]) in
  (( rs with<|
      contab := ct
    ; rnext_label := cs.next_label
    ; rmenv :=rs.rmenv |+ (mn, env)
    ; rsz := rs.rsz + LENGTH env |>)
  ,( rs with<|
      contab := ct
    ; rmenv :=rs.rmenv |+ (mn, [])
    ; rnext_label := cs.next_label
    |>)
  ,(emit cs (MAP PrintC (EXPLODE str))).out)))
/\
(compile_top types rs (Tdec dec) =  
(let (ct,env,cs) = (compile_decs_wrap NONE rs [dec]) in
  let cs = (compile_print_dec types dec cs) in
  (( rs with<|
      contab := ct
    ; rnext_label := cs.next_label
    ; renv := env++rs.renv
    ; rsz := rs.rsz+LENGTH env |>)
  ,( rs with<|
      contab := ct
    ; rnext_label := cs.next_label |>)
  ,cs.out)))`;

val _ = export_theory()

